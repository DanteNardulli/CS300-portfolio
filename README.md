# CS300-portfolio

The problem at hand was to understand the performance characteristics of different data structures when used in different scenarios. This analysis was crucial for making informed decisions about which data structure to use in specific situations to optimize performance. To approach this problem, I first implemented several common data structures, including arrays, linked lists, stacks, queues, trees, and hash tables. Then, I conducted experiments to measure the run-time and memory usage of each data structure under different conditions, such as insertion, deletion, searching, and traversal operations. I used algorithms and techniques to collect accurate measurements and analyze the results effectively. Understanding data structures is essential for every programmer because they provide the foundation for organizing and managing data efficiently in computer programs. By learning about different data structures and their performance characteristics, I gained insights into how to choose the right data structure for a given problem, considering factors like time complexity, space complexity, and the nature of the data being processed. Throughout the project, I encountered roadblocks such as understanding the intricacies of memory management, debugging performance issues, and interpreting experimental results accurately. To overcome these challenges, I leveraged resources such as textbooks, online tutorials, and discussions with peers and instructors. I also experimented with different approaches and techniques, refining my understanding and problem-solving skills in the process. Working on this project expanded my approach to designing software and developing programs in several ways. Firstly, I developed a deeper understanding of algorithmic complexity and its impact on program performance. This knowledge enabled me to make more informed design decisions and write more efficient code. Additionally, I learned how to conduct rigorous experiments and analyze empirical data to validate hypotheses and draw meaningful conclusions. Furthermore, my work on this project evolved the way I write programs to be maintainable, readable, and adaptable. By focusing on performance analysis and optimization, I became more conscious of writing clean, modular, and well-documented code. I learned the importance of writing code that is easy to understand, maintain, and extend, especially when collaborating with others or revisiting projects in the future. Overall, this project sharpened my skills as a software developer and equipped me with valuable insights and techniques for building high-quality software systems.
